[{"categories":["技术分享"],"content":" 如果你正在使用 Vue 3，并且还在纠结于状态管理方案，那么请停下脚步，认识一下 Pinia。作为 Vuex 的下一代替代者，Pinia 由 Vue 核心团队成员亲自操刀，并已成为 Vue 3 官方推荐的状态管理库。它以其惊人的简洁性、完整的 TypeScript 支持和直观的设计理念，正在迅速赢得开发者的青睐。 本文将带你全面了解 Pinia，从核心概念到高级技巧，让你轻松上手，并在项目中发挥其最大威力。 ","date":"2025-08-03","objectID":"/blog/posts/vue-pina-post/:0:0","tags":["Pinia","Vue","前端"],"title":"Vue 3 状态管理终极指南：从入门到精通 Pinia","uri":"/blog/posts/vue-pina-post/"},{"categories":["技术分享"],"content":"一、为什么选择 Pinia？告别 Vuex 的繁琐 相比于 Vuex，Pinia 带来了许多令人振奋的改进： 天生 TypeScript 支持：无需复杂的类型定义，享受完美的自动补全和类型推断。 极致简洁的 API：告别 mutations！Actions 支持同步和异步操作，代码更直观，心智负担更小。 扁平化的模块设计：每个 Store 都是一个独立的模块，天然具备模块化能力，Store 之间调用非常简单。 强大的 DevTools 支持：完美集成 Vue DevTools，无论是 state 变化跟踪还是时间旅行调试，都易如反掌。 轻量与高效：体积非常小，且经过优化，对性能影响微乎其微。 ","date":"2025-08-03","objectID":"/blog/posts/vue-pina-post/:1:0","tags":["Pinia","Vue","前端"],"title":"Vue 3 状态管理终极指南：从入门到精通 Pinia","uri":"/blog/posts/vue-pina-post/"},{"categories":["技术分享"],"content":"二、Pinia 的核心三剑客：State, Getters, Actions 理解 Pinia，只需掌握它的三个核心概念。我们可以用 Vue 组件的概念来类比： state：相当于组件的 data，是 Store 的数据源，存储着最核心的状态。 getters：相当于组件的 computed，是基于 state 派生出的计算属性，当依赖的 state 变化时会自动更新。 actions：相当于组件的 methods，用于封装业务逻辑，可以修改 state。它既可以处理同步逻辑，也可以处理异步逻辑（如 API 请求）。 ","date":"2025-08-03","objectID":"/blog/posts/vue-pina-post/:2:0","tags":["Pinia","Vue","前端"],"title":"Vue 3 状态管理终极指南：从入门到精通 Pinia","uri":"/blog/posts/vue-pina-post/"},{"categories":["技术分享"],"content":"三、Pinia 快速上手 让我们通过一个经典的计数器案例，感受 Pinia 的魅力。 ","date":"2025-08-03","objectID":"/blog/posts/vue-pina-post/:3:0","tags":["Pinia","Vue","前端"],"title":"Vue 3 状态管理终极指南：从入门到精通 Pinia","uri":"/blog/posts/vue-pina-post/"},{"categories":["技术分享"],"content":"第一步：安装与挂载 # 使用 npm 或 yarn 安装 npm install pinia # yarn add pinia 在你的 main.ts (或 main.js) 中引入并使用它。 import { createApp } from 'vue' import { createPinia } from 'pinia' import App from './App.vue' const app = createApp(App) // 创建 Pinia 实例并挂载 app.use(createPinia()) app.mount('#app') ","date":"2025-08-03","objectID":"/blog/posts/vue-pina-post/:3:1","tags":["Pinia","Vue","前端"],"title":"Vue 3 状态管理终极指南：从入门到精通 Pinia","uri":"/blog/posts/vue-pina-post/"},{"categories":["技术分享"],"content":"第二步：定义你的第一个 Store 在 src/stores 目录下创建一个 counter.ts 文件。 import { defineStore } from 'pinia' // 使用 defineStore 定义一个 store // 第一个参数是 store 的唯一 ID，Pinia 用它来连接 DevTools export const useCounterStore = defineStore('counter', { // state: 定义状态的地方，必须是函数形式以避免服务端渲染的交叉请求污染 state: () =\u003e ({ count: 0, name: 'Pinia' }), // getters: 类似计算属性 getters: { // 接收 state 作为第一个参数 doubleCount: (state) =\u003e state.count * 2, // 也可以通过 this 访问 store 实例的其他属性，但需要显式定义返回类型 greeting(): string { return `Hello, ${this.name}! My double count is ${this.doubleCount}.` } }, // actions: 类似方法 actions: { increment() { // 在 action 中可以直接通过 this 修改 state this.count++ }, async incrementAsync() { // 支持异步操作 await new Promise(resolve =\u003e setTimeout(resolve, 1000)) this.increment() // 可以直接调用其他 action } } }) ","date":"2025-08-03","objectID":"/blog/posts/vue-pina-post/:3:2","tags":["Pinia","Vue","前端"],"title":"Vue 3 状态管理终极指南：从入门到精通 Pinia","uri":"/blog/posts/vue-pina-post/"},{"categories":["技术分享"],"content":"第三步：在组件中优雅地使用 在任何 Vue 组件中，你都可以轻松地调用 Store。 \u003ctemplate\u003e \u003cdiv\u003e \u003cp\u003eCount: {{ counterStore.count }}\u003c/p\u003e \u003cp\u003eDouble Count: {{ counterStore.doubleCount }}\u003c/p\u003e \u003cp\u003e{{ counterStore.greeting }}\u003c/p\u003e \u003cbutton @click=\"counterStore.increment\"\u003eIncrement\u003c/button\u003e \u003cbutton @click=\"counterStore.incrementAsync\"\u003eIncrement Async\u003c/button\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript setup lang=\"ts\"\u003e import { useCounterStore } from './stores/counter' // 在 setup 中调用 useStore() 函数即可获取 store 实例 const counterStore = useCounterStore() \u003c/script\u003e ","date":"2025-08-03","objectID":"/blog/posts/vue-pina-post/:3:3","tags":["Pinia","Vue","前端"],"title":"Vue 3 状态管理终极指南：从入门到精通 Pinia","uri":"/blog/posts/vue-pina-post/"},{"categories":["技术分享"],"content":"四、Pinia 进阶技巧 ","date":"2025-08-03","objectID":"/blog/posts/vue-pina-post/:4:0","tags":["Pinia","Vue","前端"],"title":"Vue 3 状态管理终极指南：从入门到精通 Pinia","uri":"/blog/posts/vue-pina-post/"},{"categories":["技术分享"],"content":"4.1 多种姿势修改 State Pinia 提供了多种灵活的方式来修改状态： // 方式1：最直接的修改 counterStore.count++ // 方式2：通过 action（推荐，便于逻辑封装） counterStore.increment() // 方式3：使用 $patch 批量修改（对象形式，性能更优） counterStore.$patch({ count: counterStore.count + 2, name: 'New Name' }) // 方式4：使用 $patch 批量修改（函数形式，适用于复杂逻辑） counterStore.$patch((state) =\u003e { state.count += 3 state.name = 'Updated Name' }) ","date":"2025-08-03","objectID":"/blog/posts/vue-pina-post/:4:1","tags":["Pinia","Vue","前端"],"title":"Vue 3 状态管理终极指南：从入门到精通 Pinia","uri":"/blog/posts/vue-pina-post/"},{"categories":["技术分享"],"content":"4.2 状态持久化 想让用户刷新页面后数据依然存在？使用 pinia-plugin-persistedstate 插件即可轻松实现。 npm install pinia-plugin-persistedstate 在 main.ts 中注册插件： import { createPinia } from 'pinia' import piniaPluginPersistedstate from 'pinia-plugin-persistedstate' const pinia = createPinia() pinia.use(piniaPluginPersistedstate) // 注册插件 // ... app.use(pinia) 在需要持久化的 Store 中开启 persist 选项： export const useCounterStore = defineStore('counter', { state: () =\u003e ({ count: 0 }), // 开启持久化，默认存储在 localStorage persist: true }) ","date":"2025-08-03","objectID":"/blog/posts/vue-pina-post/:4:2","tags":["Pinia","Vue","前端"],"title":"Vue 3 状态管理终极指南：从入门到精通 Pinia","uri":"/blog/posts/vue-pina-post/"},{"categories":["技术分享"],"content":"4.3 Store 间的通讯 在 Pinia 中，Store 之间的调用就跟普通函数调用一样简单。 // stores/user.ts import { defineStore } from 'pinia' import { useCounterStore } from './counter' // 直接引入 counter store export const useUserStore = defineStore('user', { actions: { login() { console.log('User logged in!') // 获取 counter store 实例并调用它的 action const counterStore = useCounterStore() counterStore.increment() } } }) ","date":"2025-08-03","objectID":"/blog/posts/vue-pina-post/:4:3","tags":["Pinia","Vue","前端"],"title":"Vue 3 状态管理终极指南：从入门到精通 Pinia","uri":"/blog/posts/vue-pina-post/"},{"categories":["技术分享"],"content":"五、Pinia vs. Vuex：王者之争 特性 Pinia Vuex (4.x) Mutations 无，Actions 直接修改 State 有，必须通过 Mutations 修改 State TypeScript 原生完美支持，无需额外配置 需要复杂的类型体操和额外配置 模块化 天然模块化，每个 Store 就是一个模块 需要通过 modules 选项配置，嵌套较深 代码简洁度 极高，模板代码少，心智负担低 较低，概念多，模板代码多 Vue 3 兼容性 完美契合，为 Composition API 设计 较好，但设计理念更偏向 Options API 对于新的 Vue 3 项目，答案是明确的：Pinia 是更现代、更简洁、更强大的选择。 ","date":"2025-08-03","objectID":"/blog/posts/vue-pina-post/:5:0","tags":["Pinia","Vue","前端"],"title":"Vue 3 状态管理终极指南：从入门到精通 Pinia","uri":"/blog/posts/vue-pina-post/"},{"categories":["技术分享"],"content":"六、结语 Pinia 以其优雅的设计和出色的开发体验，真正地简化了 Vue 的状态管理。它不仅解决了 Vuex 的许多痛点，还完美融入了 Vue 3 的生态系统。如果你还没有尝试过，不妨在下一个项目中拥抱 Pinia，相信它会给你带来惊喜。 ","date":"2025-08-03","objectID":"/blog/posts/vue-pina-post/:6:0","tags":["Pinia","Vue","前端"],"title":"Vue 3 状态管理终极指南：从入门到精通 Pinia","uri":"/blog/posts/vue-pina-post/"},{"categories":["技术分享"],"content":" 在微服务架构的浪潮中，服务的动态管理和配置的集中化成为了开发者必须面对的核心挑战。此时，Nacos 如同瑞士军刀一般，为我们提供了优雅而强大的一站式解决方案。本文将带你从零开始，深入理解 Nacos 的核心功能，并实战演示如何将其无缝集成到 Spring Cloud 项目中。 ","date":"2025-08-01","objectID":"/blog/posts/spring-nacos-post/:0:0","tags":["Nacos","Spring","Spring Cloud","后端"],"title":"深入浅出 Spring Cloud Nacos：一站式搞定服务发现与配置管理","uri":"/blog/posts/spring-nacos-post/"},{"categories":["技术分享"],"content":"一、Nacos 是什么？为什么选择它？ Nacos (Dynamic Naming and Configuration Service) 是阿里巴巴开源的一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。简单来说，它在一个项目里同时扮演了两个关键角色：服务注册中心 和 配置中心。 选择 Nacos 的核心优势在于： 功能合一：无需再同时维护 Eureka/Consul 和 Spring Cloud Config 两套系统，Nacos 一站式搞定。 灵活的模式：同时支持 AP（高可用）和 CP（高一致性）模式，你可以根据业务场景在服务发现上灵活切换，满足不同需求。 动态配置，实时生效：修改配置后，应用无需重启即可感知变化，极大提升了运维效率。 强大的控制台：提供美观易用的可视化界面，方便我们监控服务状态、管理配置。 服务健康检查：能自动探测服务实例的健康状况，并智能地摘除不健康的实例，保障系统整体的稳定性。 ","date":"2025-08-01","objectID":"/blog/posts/spring-nacos-post/:1:0","tags":["Nacos","Spring","Spring Cloud","后端"],"title":"深入浅出 Spring Cloud Nacos：一站式搞定服务发现与配置管理","uri":"/blog/posts/spring-nacos-post/"},{"categories":["技术分享"],"content":"二、Nacos 实战：集成 Spring Cloud 接下来，我们通过一个典型的 Spring Cloud 项目，看看集成 Nacos 有多简单。 ","date":"2025-08-01","objectID":"/blog/posts/spring-nacos-post/:2:0","tags":["Nacos","Spring","Spring Cloud","后端"],"title":"深入浅出 Spring Cloud Nacos：一站式搞定服务发现与配置管理","uri":"/blog/posts/spring-nacos-post/"},{"categories":["技术分享"],"content":"2.1 作为服务注册与发现中心 目标：让我们的微服务自动注册到 Nacos，并且能够互相发现。 第一步：添加 Maven 依赖 在你的 pom.xml 文件中，引入 nacos-discovery 的 starter。 \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-alibaba-nacos-discovery\u003c/artifactId\u003e \u003c/dependency\u003e 第二步：配置 Nacos 服务器地址 在 application.yml 中，指定 Nacos 的地址。 spring: application: # 为你的服务起一个名字 name: order-service cloud: nacos: discovery: # Nacos Server 的地址 server-addr: 127.0.0.1:8848 第三步：在启动类上开启服务发现 在 Spring Boot 的主启动类上添加 @EnableDiscoveryClient 注解。 @SpringBootApplication @EnableDiscoveryClient // 声明这是一个Nacos客户端 public class ServiceApplication { public static void main(String[] args) { SpringApplication.run(ServiceApplication.class, args); } } 启动应用后，你就可以在 Nacos 控制台的 “服务管理” -\u003e “服务列表” 中看到名为 order-service 的服务已经成功注册了！ ","date":"2025-08-01","objectID":"/blog/posts/spring-nacos-post/:2:1","tags":["Nacos","Spring","Spring Cloud","后端"],"title":"深入浅出 Spring Cloud Nacos：一站式搞定服务发现与配置管理","uri":"/blog/posts/spring-nacos-post/"},{"categories":["技术分享"],"content":"2.2 作为统一配置中心 目标：将应用的配置信息从代码中抽离，交由 Nacos 统一管理。 第一步：添加 Maven 依赖 同样，在 pom.xml 中引入 nacos-config 的 starter。 \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-alibaba-nacos-config\u003c/artifactId\u003e \u003c/dependency\u003e 第二步：创建 bootstrap.yml 注意：配置中心的配置需要优先于 application.yml 加载，因此必须写在 bootstrap.yml 文件中。 spring: application: # 同样需要指定服务名，Nacos会根据它来查找配置 name: user-service cloud: nacos: config: server-addr: 127.0.0.1:8848 # 指定配置文件格式 file-extension: yaml 第三步：在 Nacos 控制台创建配置 登录 Nacos 控制台，进入 “配置管理” -\u003e “配置列表”。 点击 “+” 号创建新配置。 填写 Data ID： user-service.yaml (格式通常为 ${spring.application.name}.${file-extension}) 选择配置格式为 YAML。 在“配置内容”中输入 ： user: name: CoderWang age: 25 点击“发布”。 第四步：在代码中动态获取配置 使用 @Value 注解读取配置，并添加 @RefreshScope 注解以支持配置的动态刷新。 @RestController @RefreshScope // 这个注解是实现配置动态刷新的关键！ public class UserController { @Value(\"${user.name}\") private String userName; @GetMapping(\"/user/name\") public String getUserName() { // 返回从Nacos获取的用户名 return \"Current user name is: \" + userName; } } 现在，启动应用并访问 /user/name。然后尝试在 Nacos 控制台修改 user.name 的值并发布，再次访问该接口，你会发现无需重启应用，返回的值已经更新了！ ","date":"2025-08-01","objectID":"/blog/posts/spring-nacos-post/:2:2","tags":["Nacos","Spring","Spring Cloud","后端"],"title":"深入浅出 Spring Cloud Nacos：一站式搞定服务发现与配置管理","uri":"/blog/posts/spring-nacos-post/"},{"categories":["技术分享"],"content":"三、Nacos 进阶特性 命名空间 (Namespace)：这是进行环境隔离的核心。你可以为 dev、test、prod 等不同环境创建不同的命名空间，实现配置和服务的天然隔离，非常安全。 配置分组 (Group)：当一个项目内有多种不同业务的配置时，可以使用 Group 来进行逻辑划分，使配置管理更加清晰。 服务健康检查：Nacos Client 会定期向 Server 发送心跳，告知自己“还活着”。如果 Server 长时间未收到心跳，就会将该实例标记为不健康，并从服务列表中临时剔除，从而避免流量流向已宕机的服务，实现服务调用的高可用。 ","date":"2025-08-01","objectID":"/blog/posts/spring-nacos-post/:3:0","tags":["Nacos","Spring","Spring Cloud","后端"],"title":"深入浅出 Spring Cloud Nacos：一站式搞定服务发现与配置管理","uri":"/blog/posts/spring-nacos-post/"},{"categories":["技术分享"],"content":"四、总结 Nacos 凭借其集服务发现与配置管理于一身的强大能力，以及与 Spring Cloud 生态的无缝集成，已成为构建现代化微服务架构的首选组件之一。它极大地简化了服务的治理和配置的维护，让开发者可以更专注于业务逻辑的实现。 ","date":"2025-08-01","objectID":"/blog/posts/spring-nacos-post/:4:0","tags":["Nacos","Spring","Spring Cloud","后端"],"title":"深入浅出 Spring Cloud Nacos：一站式搞定服务发现与配置管理","uri":"/blog/posts/spring-nacos-post/"},{"categories":["技术分享"],"content":"本文将带你系统性地梳理 Spring 框架的核心知识，从两大基石 IoC 和 AOP，到现代化的开发利器 Spring Boot，再到庞大的 Spring 生态，助你构建完整的知识体系。","date":"2024-10-27","objectID":"/blog/posts/spring-springboot-post/","tags":["Java","Spring","Spring Boot","后端"],"title":"深入浅出 Spring：从核心原理到 Spring Boot 实战，一篇通关！","uri":"/blog/posts/spring-springboot-post/"},{"categories":["技术分享"],"content":" 在 Java 的世界里，如果你只选择一个框架来学习，那答案几乎毫无疑问是 Spring。自 2003 年诞生以来，它如同一位技艺精湛的工匠，彻底重塑了 Java 企业级应用的开发模式。它优雅地解决了传统开发中令人头疼的代码耦合、笨重臃肿等问题，成为了 Java 后端开发领域当之无愧的基石。 本文将带你进行一次 Spring 的深度之旅，从它的核心设计哲学出发，逐步探索其关键模块、现代化的开发利器 Spring Boot，以及那个庞大而繁荣的生态系统。 ","date":"2024-10-27","objectID":"/blog/posts/spring-springboot-post/:0:0","tags":["Java","Spring","Spring Boot","后端"],"title":"深入浅出 Spring：从核心原理到 Spring Boot 实战，一篇通关！","uri":"/blog/posts/spring-springboot-post/"},{"categories":["技术分享"],"content":"一、为何 Spring 能长盛不衰？三大核心优势 Spring 的成功并非偶然，其核心优势在于它始终遵循着一套先进的设计哲学。 Spring 的两大灵魂基石是：依赖注入（DI） 和 面向切面编程（AOP）。前者负责解耦组件，后者负责分离业务关注点。 这套组合拳带来了三大显而易见的优势： 极致的松耦合架构：通过控制反转（IoC）容器，对象的创建和依赖关系的管理权被交给了 Spring。开发者不再是组件的“生产者”，而是“消费者”，只需告诉 Spring “我需要什么”，Spring 就会在恰当的时候提供给你。这大大降低了代码间的耦合度。 轻量级与非侵入式设计：Spring 核心容器本身非常小巧，更重要的是，你可以自由选择使用 Spring 的哪个部分。你的业务对象（POJO）无需继承任何特定的类或实现特定的接口，保持了代码的纯粹性。 强大的生态与扩展性：Spring 从未固步自封。它构建了一个庞大的“全家桶”生态，从 Web 开发（Spring MVC）、数据访问（Spring Data）到微服务（Spring Cloud），几乎覆盖了后端开发的所有场景，为开发者提供了“一站式”的解决方案。 ","date":"2024-10-27","objectID":"/blog/posts/spring-springboot-post/:1:0","tags":["Java","Spring","Spring Boot","后端"],"title":"深入浅出 Spring：从核心原理到 Spring Boot 实战，一篇通关！","uri":"/blog/posts/spring-springboot-post/"},{"categories":["技术分享"],"content":"二、剖析 Spring 的“心脏”：核心模块解析 Spring 框架如同一套精密的组件库，每个模块各司其职，又可无缝协作。 ","date":"2024-10-27","objectID":"/blog/posts/spring-springboot-post/:2:0","tags":["Java","Spring","Spring Boot","后端"],"title":"深入浅出 Spring：从核心原理到 Spring Boot 实战，一篇通关！","uri":"/blog/posts/spring-springboot-post/"},{"categories":["技术分享"],"content":"2.1 Spring Core：控制反转（IoC）的魔法容器 这是 Spring 的基础。IoC（Inversion of Control），即控制反转，是一种设计思想，而依赖注入（Dependency Injection, DI） 是其最经典的实现方式。 简单来说，IoC 就像一个神通广大的管家。 以前，你需要某个工具（对象），得自己去造（new UserServiceImpl())。现在，你只需要告诉管家（Spring IoC 容器）你的需求清单，管家会负责帮你把所有工具准备好，并在你需要时递到你手上。 // 传统方式：主动创建对象，耦合度高 UserService userService = new UserServiceImpl(); // Spring 方式：从容器中获取，由 Spring 负责对象的生命周期 // 我们只管使用，不管创建 UserService userService = context.getBean(UserService.class); ","date":"2024-10-27","objectID":"/blog/posts/spring-springboot-post/:2:1","tags":["Java","Spring","Spring Boot","后端"],"title":"深入浅出 Spring：从核心原理到 Spring Boot 实战，一篇通关！","uri":"/blog/posts/spring-springboot-post/"},{"categories":["技术分享"],"content":"2.2 Spring AOP：优雅分离横切关注点 AOP（Aspect-Oriented Programming），即面向切面编程，是 OOP（面向对象编程）的有力补充。它允许我们将那些散布在各个业务逻辑中的“公共代码”抽离出来，形成一个独立的“切面”。 这些公共代码就是横切关注点（Cross-cutting Concerns），最常见的应用场景包括： 日志记录：在方法执行前后自动打印出入参和耗时。 事务管理：通过一个注解（如 @Transactional）就能让方法整体运行在一个事务中。 权限校验：在方法执行前统一检查用户权限。 AOP 让我们的业务代码能更专注于核心逻辑，变得更加纯粹和可维护。 ","date":"2024-10-27","objectID":"/blog/posts/spring-springboot-post/:2:2","tags":["Java","Spring","Spring Boot","后端"],"title":"深入浅出 Spring：从核心原理到 Spring Boot 实战，一篇通关！","uri":"/blog/posts/spring-springboot-post/"},{"categories":["技术分享"],"content":"2.3 Spring MVC：经典的 Web 开发框架 Spring MVC 是一个基于 MVC 设计模式的 Web 框架，它采用前端控制器模式（Front Controller Pattern），将所有请求都先交给一个核心的 DispatcherServlet 来分发，极大地简化了 Web 开发。 其核心组件协同工作的流程如下： DispatcherServlet：接收所有请求，是整个流程的“总指挥”。 HandlerMapping：根据请求 URL 找到对应的 Controller（处理器）。 Controller：处理业务逻辑，返回一个 ModelAndView 对象。 ViewResolver：根据 Controller 返回的视图名，找到对应的视图（如 JSP, Thymeleaf 模板）。 最终，将模型数据渲染到视图上，并返回给用户。 ","date":"2024-10-27","objectID":"/blog/posts/spring-springboot-post/:2:3","tags":["Java","Spring","Spring Boot","后端"],"title":"深入浅出 Spring：从核心原理到 Spring Boot 实战，一篇通关！","uri":"/blog/posts/spring-springboot-post/"},{"categories":["技术分享"],"content":"三、Spring Boot：化繁为简，让开发“飞”起来 尽管 Spring 已经非常优秀，但其繁琐的 XML 配置也曾劝退过不少开发者。为了解决这个问题，Spring Boot 横空出世。 Spring Boot 的核心思想是 “约定优于配置”（Convention over Configuration）。 它假设了大多数开发场景下的最佳实践，并将其作为默认配置。开发者不再需要编写大量的模板代码，可以真正做到“开箱即用”。 ","date":"2024-10-27","objectID":"/blog/posts/spring-springboot-post/:3:0","tags":["Java","Spring","Spring Boot","后端"],"title":"深入浅出 Spring：从核心原理到 Spring Boot 实战，一篇通关！","uri":"/blog/posts/spring-springboot-post/"},{"categories":["技术分享"],"content":"3.1 Spring Boot 的核心特性 自动配置（Auto-configuration）：这是 Spring Boot 的“魔法”所在。它会根据你项目中引入的依赖，自动为你配置好相应的 Bean。例如，只要引入了 spring-boot-starter-web，它就会自动配置好 Tomcat 和 Spring MVC。 起步依赖（Starter Dependencies）：将一类场景所需的所有依赖打包成一个 starter。例如，你需要开发 Web 应用，只需引入 spring-boot-starter-web，所有相关的依赖（如 Tomcat, Jackson, Spring MVC）就都自动包含了，彻底告别了繁琐的依赖管理。 内嵌式服务器：无需再将应用打包成 WAR 包部署到外部的 Tomcat。Spring Boot 内置了 Tomcat, Jetty, Undertow 等服务器，可以直接将应用打包成一个可执行的 JAR 文件，通过 java -jar 命令一键启动。 ","date":"2024-10-27","objectID":"/blog/posts/spring-springboot-post/:3:1","tags":["Java","Spring","Spring Boot","后端"],"title":"深入浅出 Spring：从核心原理到 Spring Boot 实战，一篇通关！","uri":"/blog/posts/spring-springboot-post/"},{"categories":["技术分享"],"content":"3.2 快速入门：3 步创建 RESTful 接口 感受一下 Spring Boot 的极简之美： 添加 spring-boot-starter-web 依赖： \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e 编写一个主启动类： @SpringBootApplication // 一个注解顶过去三个 public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } } 实现一个控制器： @RestController // 声明这是一个RESTful控制器 public class HelloController { @GetMapping(\"/hello\") // 映射HTTP GET请求到 /hello 路径 public String hello() { return \"Hello, Spring Boot!\"; } } 启动应用，访问 http://localhost:8080/hello，就这么简单！ ","date":"2024-10-27","objectID":"/blog/posts/spring-springboot-post/:3:2","tags":["Java","Spring","Spring Boot","后端"],"title":"深入浅出 Spring：从核心原理到 Spring Boot 实战，一篇通关！","uri":"/blog/posts/spring-springboot-post/"},{"categories":["技术分享"],"content":"四、Spring 的“全家桶”：庞大的生态系统 Spring 的强大远不止于此，它的生态系统几乎涵盖了软件开发的所有方面。 Spring Cloud：构建分布式系统和微服务架构的“瑞士军刀”，提供服务发现、配置中心、网关等全套解决方案。 Spring Data：简化数据访问层的开发，无论是关系型数据库（JPA）、NoSQL（MongoDB, Redis）都能用一套统一的、优雅的 Repository 模式来操作。 Spring Security：提供强大而灵活的认证和授权功能，是保护你应用安全的标准选择。 Spring Batch：用于处理大量数据的高效批处理框架。 Spring Integration：实现了经典的“企业集成模式”，用于连接不同的系统和应用。 ","date":"2024-10-27","objectID":"/blog/posts/spring-springboot-post/:4:0","tags":["Java","Spring","Spring Boot","后端"],"title":"深入浅出 Spring：从核心原理到 Spring Boot 实战，一篇通关！","uri":"/blog/posts/spring-springboot-post/"},{"categories":["技术分享"],"content":"五、避坑指南与最佳实践 要想用好 Spring，除了了解其原理，还需要遵循一些社区公认的最佳实践。 依赖注入方式选择： 优先使用构造器注入。它能保证依赖在对象创建时就已就绪，避免了 NullPointerException，也便于编写单元测试。字段注入虽然代码最少，但最不推荐。 避免循环依赖： 当 A 依赖 B，同时 B 又依赖 A 时，就会产生循环依赖。这通常是设计不良的信号，应通过重构代码来解决，而不是依赖 Spring 的三级缓存来“包容”它。 事务管理注意事项： @Transactional 注解必须应用于 public 方法上才能生效。 要警惕事务方法内部的 try-catch 块。如果异常被你“吃掉”了，事务可能不会按预期回滚。 性能优化建议： 合理使用 Bean 的作用域（Scope）。大部分 Bean 应该是单例（Singleton），对于有状态的 Bean 应谨慎选择 prototype 或 request 作用域。 使用 @Lazy 注解实现懒加载，延迟非必要 Bean 的初始化。 ","date":"2024-10-27","objectID":"/blog/posts/spring-springboot-post/:5:0","tags":["Java","Spring","Spring Boot","后端"],"title":"深入浅出 Spring：从核心原理到 Spring Boot 实战，一篇通关！","uri":"/blog/posts/spring-springboot-post/"},{"categories":["技术分享"],"content":"六、总结与展望 从一个颠覆传统 Java EE 开发的轻量级容器，到如今枝繁叶茂、无所不包的生态帝国，Spring 凭借其优雅的设计、强大的功能和活跃的社区，早已成为 Java 开发领域的事实标准。 随着 Spring 6 和 Spring Boot 3 的发布，框架全面拥抱 Java 17，并为 GraalVM 原生镜像和虚拟线程等前沿技术提供了支持，持续引领着 Java 技术的发展潮流。 对于每一位 Java 开发者而言，深入理解 Spring 的核心原理，并熟练运用其生态工具，无疑是提升个人技术实力、构建高质量应用系统的必经之路。 ","date":"2024-10-27","objectID":"/blog/posts/spring-springboot-post/:6:0","tags":["Java","Spring","Spring Boot","后端"],"title":"深入浅出 Spring：从核心原理到 Spring Boot 实战，一篇通关！","uri":"/blog/posts/spring-springboot-post/"},{"categories":null,"content":"了解更多关于MonkeyKe和这个博客的故事。","date":"2023-08-26","objectID":"/blog/about/","tags":null,"title":"关于我","uri":"/blog/about/"},{"categories":null,"content":"👋 大家好！ 我是 MonkeyKe，一名热爱探索的开发者。 欢迎来到我的个人博客 “猿客随笔”。我创建这个空间是为了： 记录 我在技术学习道路上的心得和体会。 分享 一些有趣的项目和实用的工具。 思考 技术之外的生活和感悟。 ","date":"2023-08-26","objectID":"/blog/about/:1:0","tags":null,"title":"关于我","uri":"/blog/about/"},{"categories":null,"content":"我的技术栈 前端: Vue.js, React,Uniapp… 后端: Node.js, Go,Java,Scala,SpringBoot,SpringCloud… 数据库: MongoDB, MySQL… 大数据：Hive,Hadoop,Spark,Flink… ","date":"2023-08-26","objectID":"/blog/about/:1:1","tags":null,"title":"关于我","uri":"/blog/about/"},{"categories":null,"content":"联系我 您可以通过以下方式找到我： GitHub: monkeyke Email: contact@monkeyke.com 感谢您的来访！ ","date":"2023-08-26","objectID":"/blog/about/:1:2","tags":null,"title":"关于我","uri":"/blog/about/"}]